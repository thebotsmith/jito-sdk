// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.24.4
// source: searcher.proto

package searcher

import (
	context "context"
	bundle "github.com/Prophet-Solutions/jito-sdk/pb/bundle"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SearcherService_SubscribeBundleResults_FullMethodName      = "/searcher.SearcherService/SubscribeBundleResults"
	SearcherService_SendBundle_FullMethodName                  = "/searcher.SearcherService/SendBundle"
	SearcherService_GetNextScheduledLeader_FullMethodName      = "/searcher.SearcherService/GetNextScheduledLeader"
	SearcherService_GetConnectedLeaders_FullMethodName         = "/searcher.SearcherService/GetConnectedLeaders"
	SearcherService_GetConnectedLeadersRegioned_FullMethodName = "/searcher.SearcherService/GetConnectedLeadersRegioned"
	SearcherService_GetTipAccounts_FullMethodName              = "/searcher.SearcherService/GetTipAccounts"
	SearcherService_GetRegions_FullMethodName                  = "/searcher.SearcherService/GetRegions"
)

// SearcherServiceClient is the client API for SearcherService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SearcherServiceClient interface {
	// Searchers can invoke this endpoint to subscribe to their respective bundle results.
	// A success result would indicate the bundle won its state auction and was submitted to the validator.
	SubscribeBundleResults(ctx context.Context, in *SubscribeBundleResultsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[bundle.BundleResult], error)
	SendBundle(ctx context.Context, in *SendBundleRequest, opts ...grpc.CallOption) (*SendBundleResponse, error)
	// Returns the next scheduled leader connected to the block engine.
	GetNextScheduledLeader(ctx context.Context, in *NextScheduledLeaderRequest, opts ...grpc.CallOption) (*NextScheduledLeaderResponse, error)
	// Returns leader slots for connected jito validators during the current epoch. Only returns data for this region.
	GetConnectedLeaders(ctx context.Context, in *ConnectedLeadersRequest, opts ...grpc.CallOption) (*ConnectedLeadersResponse, error)
	// Returns leader slots for connected jito validators during the current epoch.
	GetConnectedLeadersRegioned(ctx context.Context, in *ConnectedLeadersRegionedRequest, opts ...grpc.CallOption) (*ConnectedLeadersRegionedResponse, error)
	// Returns the tip accounts searchers shall transfer funds to for the leader to claim.
	GetTipAccounts(ctx context.Context, in *GetTipAccountsRequest, opts ...grpc.CallOption) (*GetTipAccountsResponse, error)
	// Returns region the client is directly connected to, along with all available regions
	GetRegions(ctx context.Context, in *GetRegionsRequest, opts ...grpc.CallOption) (*GetRegionsResponse, error)
}

type searcherServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearcherServiceClient(cc grpc.ClientConnInterface) SearcherServiceClient {
	return &searcherServiceClient{cc}
}

func (c *searcherServiceClient) SubscribeBundleResults(ctx context.Context, in *SubscribeBundleResultsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[bundle.BundleResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SearcherService_ServiceDesc.Streams[0], SearcherService_SubscribeBundleResults_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeBundleResultsRequest, bundle.BundleResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SearcherService_SubscribeBundleResultsClient = grpc.ServerStreamingClient[bundle.BundleResult]

func (c *searcherServiceClient) SendBundle(ctx context.Context, in *SendBundleRequest, opts ...grpc.CallOption) (*SendBundleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendBundleResponse)
	err := c.cc.Invoke(ctx, SearcherService_SendBundle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searcherServiceClient) GetNextScheduledLeader(ctx context.Context, in *NextScheduledLeaderRequest, opts ...grpc.CallOption) (*NextScheduledLeaderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NextScheduledLeaderResponse)
	err := c.cc.Invoke(ctx, SearcherService_GetNextScheduledLeader_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searcherServiceClient) GetConnectedLeaders(ctx context.Context, in *ConnectedLeadersRequest, opts ...grpc.CallOption) (*ConnectedLeadersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectedLeadersResponse)
	err := c.cc.Invoke(ctx, SearcherService_GetConnectedLeaders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searcherServiceClient) GetConnectedLeadersRegioned(ctx context.Context, in *ConnectedLeadersRegionedRequest, opts ...grpc.CallOption) (*ConnectedLeadersRegionedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectedLeadersRegionedResponse)
	err := c.cc.Invoke(ctx, SearcherService_GetConnectedLeadersRegioned_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searcherServiceClient) GetTipAccounts(ctx context.Context, in *GetTipAccountsRequest, opts ...grpc.CallOption) (*GetTipAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTipAccountsResponse)
	err := c.cc.Invoke(ctx, SearcherService_GetTipAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searcherServiceClient) GetRegions(ctx context.Context, in *GetRegionsRequest, opts ...grpc.CallOption) (*GetRegionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegionsResponse)
	err := c.cc.Invoke(ctx, SearcherService_GetRegions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearcherServiceServer is the server API for SearcherService service.
// All implementations must embed UnimplementedSearcherServiceServer
// for forward compatibility.
type SearcherServiceServer interface {
	// Searchers can invoke this endpoint to subscribe to their respective bundle results.
	// A success result would indicate the bundle won its state auction and was submitted to the validator.
	SubscribeBundleResults(*SubscribeBundleResultsRequest, grpc.ServerStreamingServer[bundle.BundleResult]) error
	SendBundle(context.Context, *SendBundleRequest) (*SendBundleResponse, error)
	// Returns the next scheduled leader connected to the block engine.
	GetNextScheduledLeader(context.Context, *NextScheduledLeaderRequest) (*NextScheduledLeaderResponse, error)
	// Returns leader slots for connected jito validators during the current epoch. Only returns data for this region.
	GetConnectedLeaders(context.Context, *ConnectedLeadersRequest) (*ConnectedLeadersResponse, error)
	// Returns leader slots for connected jito validators during the current epoch.
	GetConnectedLeadersRegioned(context.Context, *ConnectedLeadersRegionedRequest) (*ConnectedLeadersRegionedResponse, error)
	// Returns the tip accounts searchers shall transfer funds to for the leader to claim.
	GetTipAccounts(context.Context, *GetTipAccountsRequest) (*GetTipAccountsResponse, error)
	// Returns region the client is directly connected to, along with all available regions
	GetRegions(context.Context, *GetRegionsRequest) (*GetRegionsResponse, error)
	mustEmbedUnimplementedSearcherServiceServer()
}

// UnimplementedSearcherServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearcherServiceServer struct{}

func (UnimplementedSearcherServiceServer) SubscribeBundleResults(*SubscribeBundleResultsRequest, grpc.ServerStreamingServer[bundle.BundleResult]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeBundleResults not implemented")
}
func (UnimplementedSearcherServiceServer) SendBundle(context.Context, *SendBundleRequest) (*SendBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBundle not implemented")
}
func (UnimplementedSearcherServiceServer) GetNextScheduledLeader(context.Context, *NextScheduledLeaderRequest) (*NextScheduledLeaderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextScheduledLeader not implemented")
}
func (UnimplementedSearcherServiceServer) GetConnectedLeaders(context.Context, *ConnectedLeadersRequest) (*ConnectedLeadersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectedLeaders not implemented")
}
func (UnimplementedSearcherServiceServer) GetConnectedLeadersRegioned(context.Context, *ConnectedLeadersRegionedRequest) (*ConnectedLeadersRegionedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectedLeadersRegioned not implemented")
}
func (UnimplementedSearcherServiceServer) GetTipAccounts(context.Context, *GetTipAccountsRequest) (*GetTipAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTipAccounts not implemented")
}
func (UnimplementedSearcherServiceServer) GetRegions(context.Context, *GetRegionsRequest) (*GetRegionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegions not implemented")
}
func (UnimplementedSearcherServiceServer) mustEmbedUnimplementedSearcherServiceServer() {}
func (UnimplementedSearcherServiceServer) testEmbeddedByValue()                         {}

// UnsafeSearcherServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearcherServiceServer will
// result in compilation errors.
type UnsafeSearcherServiceServer interface {
	mustEmbedUnimplementedSearcherServiceServer()
}

func RegisterSearcherServiceServer(s grpc.ServiceRegistrar, srv SearcherServiceServer) {
	// If the following call pancis, it indicates UnimplementedSearcherServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SearcherService_ServiceDesc, srv)
}

func _SearcherService_SubscribeBundleResults_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeBundleResultsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SearcherServiceServer).SubscribeBundleResults(m, &grpc.GenericServerStream[SubscribeBundleResultsRequest, bundle.BundleResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SearcherService_SubscribeBundleResultsServer = grpc.ServerStreamingServer[bundle.BundleResult]

func _SearcherService_SendBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearcherServiceServer).SendBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearcherService_SendBundle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearcherServiceServer).SendBundle(ctx, req.(*SendBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearcherService_GetNextScheduledLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextScheduledLeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearcherServiceServer).GetNextScheduledLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearcherService_GetNextScheduledLeader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearcherServiceServer).GetNextScheduledLeader(ctx, req.(*NextScheduledLeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearcherService_GetConnectedLeaders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectedLeadersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearcherServiceServer).GetConnectedLeaders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearcherService_GetConnectedLeaders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearcherServiceServer).GetConnectedLeaders(ctx, req.(*ConnectedLeadersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearcherService_GetConnectedLeadersRegioned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectedLeadersRegionedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearcherServiceServer).GetConnectedLeadersRegioned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearcherService_GetConnectedLeadersRegioned_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearcherServiceServer).GetConnectedLeadersRegioned(ctx, req.(*ConnectedLeadersRegionedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearcherService_GetTipAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTipAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearcherServiceServer).GetTipAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearcherService_GetTipAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearcherServiceServer).GetTipAccounts(ctx, req.(*GetTipAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearcherService_GetRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearcherServiceServer).GetRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearcherService_GetRegions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearcherServiceServer).GetRegions(ctx, req.(*GetRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SearcherService_ServiceDesc is the grpc.ServiceDesc for SearcherService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearcherService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "searcher.SearcherService",
	HandlerType: (*SearcherServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendBundle",
			Handler:    _SearcherService_SendBundle_Handler,
		},
		{
			MethodName: "GetNextScheduledLeader",
			Handler:    _SearcherService_GetNextScheduledLeader_Handler,
		},
		{
			MethodName: "GetConnectedLeaders",
			Handler:    _SearcherService_GetConnectedLeaders_Handler,
		},
		{
			MethodName: "GetConnectedLeadersRegioned",
			Handler:    _SearcherService_GetConnectedLeadersRegioned_Handler,
		},
		{
			MethodName: "GetTipAccounts",
			Handler:    _SearcherService_GetTipAccounts_Handler,
		},
		{
			MethodName: "GetRegions",
			Handler:    _SearcherService_GetRegions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeBundleResults",
			Handler:       _SearcherService_SubscribeBundleResults_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "searcher.proto",
}
